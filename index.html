<!-- Substitua APENAS o JS do botão Fullscreen por este bloco -->
<script>
  const liveView = document.getElementById('liveView');
  const fsBtn = document.getElementById('fsButton');
  const videoEl = document.getElementById('webcam');

  // Se você estava aplicando transform direto, mova para uma classe opcional:
  // liveView.classList.add('mirrored'); // use só fora do fullscreen se quiser espelho

  const isNativeFullscreen = () =>
    document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

  const canRequestElementFS =
    !!(liveView.requestFullscreen || liveView.webkitRequestFullscreen || liveView.msRequestFullscreen);

  async function enterFullscreen(el) {
    if (el.requestFullscreen) return el.requestFullscreen();
    if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen(); // Safari moderno
    if (el.msRequestFullscreen) return el.msRequestFullscreen();
  }
  async function exitFullscreen() {
    if (document.exitFullscreen) return document.exitFullscreen();
    if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
    if (document.msExitFullscreen) return document.msExitFullscreen();
  }

  function enableSoftFS(on) {
    liveView.classList.toggle('soft-fs', on);
    updateFsButtonUI(on || !!isNativeFullscreen());
  }

  function updateFsButtonUI(full) {
    const label = fsBtn.querySelector('.mdc-button__label');
    if (full) {
      fsBtn.classList.add('mdc-button--raised');
      fsBtn.classList.remove('mdc-button--outlined');
      fsBtn.setAttribute('aria-pressed', 'true');
      label.textContent = 'Exit Fullscreen';
    } else {
      fsBtn.classList.remove('mdc-button--raised');
      fsBtn.classList.add('mdc-button--outlined');
      fsBtn.setAttribute('aria-pressed', 'false');
      label.textContent = 'Fullscreen';
    }
  }

  // Sincroniza UI quando sai pelo ESC/gesto
  ['fullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'].forEach((evt) => {
    document.addEventListener(evt, () => {
      // Garantir que não fique “espelhado” em fullscreen
      if (isNativeFullscreen()) {
        liveView.classList.remove('mirrored');
      }
      updateFsButtonUI(!!isNativeFullscreen());
    });
  });

  // Ajusta em mudanças de orientação para manter o cover
  window.addEventListener('orientationchange', () => {
    // Nada específico aqui além do CSS (object-fit: cover),
    // mas este hook evita reflows inesperados.
    setTimeout(() => {}, 0);
  });

  fsBtn.addEventListener('click', async () => {
    try {
      const nfs = !!isNativeFullscreen();
      const softOn = liveView.classList.contains('soft-fs');

      if (nfs || softOn) {
        // Sair de qualquer modo de fullscreen
        if (nfs) await exitFullscreen();
        if (softOn) enableSoftFS(false);
        updateFsButtonUI(false);
        return;
      }

      // ENTRAR em fullscreen
      // 1) Tente fullscreen do container (mantém vídeo/canvas no DOM)
      if (canRequestElementFS && (document.fullscreenEnabled || document.webkitFullscreenEnabled)) {
        await enterFullscreen(liveView);
        // Evita espelho no modo fullscreen
        liveView.classList.remove('mirrored');
        updateFsButtonUI(true);
        return;
      }

      // 2) Fallback: "soft fullscreen" (NÃO chamar video.webkitEnterFullscreen!)
      enableSoftFS(true);

    } catch (err) {
      console.error('Fullscreen toggle error:', err);
      // Em caso de erro, caia no soft fullscreen
      enableSoftFS(true);
    }
  });

  // Dica extra para iOS: garanta playsinline
  if (!videoEl.hasAttribute('playsinline')) {
    videoEl.setAttribute('playsinline', '');
  }
</script>
